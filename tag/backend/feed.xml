<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="http://localhost:4000/tag/backend/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2022-02-06T02:55:37+09:00</updated>
  <id>http://localhost:4000/tag/backend/feed.xml</id>

  
  
  

  
    <title type="html">Collection of studies | </title>
  

  
    <subtitle>공부 정리용 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Hoisting, Scope, Closure, Function</title>
      <link href="http://localhost:4000/backend-js-basic2" rel="alternate" type="text/html" title="Hoisting, Scope, Closure, Function" />
      <published>2022-02-05T10:00:00+09:00</published>
      <updated>2022-02-05T10:00:00+09:00</updated>
      <id>http://localhost:4000/backend-js-basic2</id>
      <content type="html" xml:base="http://localhost:4000/backend-js-basic2">&lt;p&gt;안녕하세요. 성장하는 것을 즐기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;changuk&lt;/code&gt;이라고 합니다. 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastcampus&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend&lt;/code&gt; 개발을 공부하고 있습니다. 강의를 들으면서 해온 것들을 작성하여 지식을 공유하고 또 제가 잊었을 때 다시 와서 볼 수 있도록 내용들을 정리하려고 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이번시간에는 자주 들어봤지만, 매번 헷갈리는 개념들인 Scope, Hoisting, Closure, Function 등에 대해서 짚고 넘어가고자 합니다.
JavaScript의 경우 변수간의 참조관계가 굉장히 복잡해지기 쉬우므로, 위의 개념들을 정확하게 숙지하는 것이 필요합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;hoisting---var&quot;&gt;Hoisting - var&lt;/h2&gt;

&lt;p&gt;먼저 간단한 문제를 풀면서 시작해보도록 합시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 코드가 있을 때, 출력 결과는 어떻게 될까요? 당연히 &lt;strong&gt;1&lt;/strong&gt;이 됩니다. 그럼 다음 코드는 출력 결과가 어떻게 될까요? 여기서는 &lt;strong&gt;undefined&lt;/strong&gt;가 출력됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 결과는 &lt;strong&gt;var라는 키워드의 특성&lt;/strong&gt; 때문입니다. var 키워드는 변수를 선언할 때, 그 선언이 이 scope의 맨 위로 &lt;strong&gt;Hoisting&lt;/strong&gt;이 됩니다. 간단하게 &lt;strong&gt;변수의 선언만 지금 있는 위치에서 맨 위로 끌어올린다&lt;/strong&gt;고 생각하시면 됩니다. &lt;br /&gt;
즉, 아래 코드와 동일하겠지요.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것이 &lt;strong&gt;Hoisting&lt;/strong&gt;입니다. 이 경우는 var 키워드를 사용하지 않았기 때문에 변수의 선언 자체가 이루어지지 않으므로 &lt;strong&gt;ReferenceError&lt;/strong&gt;가 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;hoisting---function&quot;&gt;Hoisting - function&lt;/h2&gt;

&lt;p&gt;아래의 코드는 각각의 실행결과가 어떻게 될까요?&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 코드의 실행결과는 동일합니다. 이유는, &lt;strong&gt;function도 Hoisting 대상이기 때문&lt;/strong&gt;입니다. 함수의 선언이 아래에 있던, 위에 있던 해당 scope의 맨 위로 올라가기 때문입니다. &lt;br /&gt;
또한 var 키워드는 선언 후 값의 초기화가 이루어지기 때문에 값의 초기화 이전에 값을 확인해보면 &lt;strong&gt;undefined&lt;/strong&gt;가 출력되지만, 함수의 선언은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function foo() {}&lt;/code&gt; 자체가 하나의 덩어리이기 때문에 위의 두 코드는 출력 결과가 동일하다고 설명드릴 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;function-lexical-scope&quot;&gt;function, lexical scope&lt;/h2&gt;

&lt;p&gt;scope가 무엇인지 확인해보도록 하죠.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/built/images/nodejs/scopebinding.png&quot; width=&quot;450&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 코드 안의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function bar() {}&lt;/code&gt; 안에서 x라는 변수를 사용하였을 때, 이 변수는 어떤 값을 가리키는지를 어떻게 판단할 수 있을까요? 코드의 어떤 식별자가 실제로 어떤 값을 가리키는지 결정하는 것을 &lt;strong&gt;binding&lt;/strong&gt; 이라고 하고 &lt;strong&gt;JavaScript&lt;/strong&gt;에서의 &lt;strong&gt;binding&lt;/strong&gt;은 &lt;strong&gt;lexical scope&lt;/strong&gt;이라는 방법을 사용하게 됩니다. &lt;br /&gt;
&lt;strong&gt;lexical scope&lt;/strong&gt;이란 간단히 말하자면 안쪽(inner scope)에서는 바깥쪽(outer scope) 변수에 접근할 수 있다는 뜻입니다.&lt;br /&gt; 다음 코드를 예로 들 수 있겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'Hello'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 &lt;strong&gt;함수 바깥의 console.log(x)는 함수 안의 x를 참조할 수 없습니다&lt;/strong&gt;. 아래의 코드는 잘 작동하겠죠?&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;Hello&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;Hello&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;var-block-scoping&quot;&gt;var, block scoping&lt;/h2&gt;

&lt;p&gt;아래 코드를 확인해보죠. x는 어떤 값을 출력할까요?&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;분명 선언을 2번 나누어서 했을 텐데, 왜 x는 2가 나올까요? 이유는 &lt;strong&gt;var가 block을 무시하기 때문&lt;/strong&gt;입니다. 따라서 선언이 합쳐지게 되고, 두 개의 x는 같은 값이 됩니다. &lt;br /&gt;(var는 위와 같은 규칙을 따르지만, let과 const는 block scoping이 됩니다.)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;closure&quot;&gt;Closure&lt;/h2&gt;

&lt;p&gt;JavaScript에서 아주 많이 듣게 될 &lt;strong&gt;Closure&lt;/strong&gt;에 대해 알아보겠습니다. Closure는 &lt;strong&gt;funcion&lt;/strong&gt; &lt;strong&gt;+&lt;/strong&gt; function을 가리키는 &lt;strong&gt;pointer&lt;/strong&gt;와 function이 참조하는 &lt;strong&gt;여러가지 변수들의 합&lt;/strong&gt; &lt;strong&gt;(=environment)&lt;/strong&gt;으로 표현됩니다.차근차근 알아봅시다.&lt;br /&gt;
&lt;strong&gt;Closure는 function이 하나 생길때 마다 하나씩 생깁니다.&lt;/strong&gt; 정확히 말씀드리자면 &lt;strong&gt;enviroment는 함수 자신을 둘러싼, 접근할 수 있는 모든 스코프&lt;/strong&gt;를 뜻합니다.
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Closure&lt;/strong&gt;의 예시부터 살펴봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; and &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;saltAnd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;and&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;saltAnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;pepper&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;saltAnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;sugar&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>Woo Chang Uk</name>
        
        
      </author>

      

      
        <category term="backend" />
      

      
        <summary type="html">안녕하세요. 성장하는 것을 즐기는 changuk이라고 합니다. 현재 fastcampus에서 backend 개발을 공부하고 있습니다. 강의를 들으면서 해온 것들을 작성하여 지식을 공유하고 또 제가 잊었을 때 다시 와서 볼 수 있도록 내용들을 정리하려고 합니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Call Stack, Non-blocking IO, Event Loop</title>
      <link href="http://localhost:4000/backend-js-basic1" rel="alternate" type="text/html" title="Call Stack, Non-blocking IO, Event Loop" />
      <published>2022-02-05T09:00:00+09:00</published>
      <updated>2022-02-05T09:00:00+09:00</updated>
      <id>http://localhost:4000/backend-js-basic1</id>
      <content type="html" xml:base="http://localhost:4000/backend-js-basic1">&lt;p&gt;안녕하세요. 성장하는 것을 즐기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;changuk&lt;/code&gt;이라고 합니다. 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastcampus&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend&lt;/code&gt; 개발을 공부하고 있습니다. 강의를 들으면서 해온 것들을 작성하여 지식을 공유하고 또 제가 잊었을 때 다시 와서 볼 수 있도록 내용들을 정리하려고 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;NodeJS를 잘 이해하기 위해서는, JavaScript의 동시성 모델(실행 모델)에 대해 잘 이해해야 합니다.
실행모델은 &lt;strong&gt;Event Loop&lt;/strong&gt;, &lt;strong&gt;Call Stack&lt;/strong&gt;, &lt;strong&gt;Callback queue&lt;/strong&gt;개념으로 이루어집니다. 이번시간은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Event Loop&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Call Stack&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Non-blocking IO&lt;/code&gt; 를 학습하도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;contents&quot;&gt;Contents&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#event-loop&quot;&gt;&lt;strong&gt;Event Loop&lt;/strong&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#call-stack&quot;&gt;&lt;strong&gt;Call Stack&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#callback-queue&quot;&gt;&lt;strong&gt;Callback Queue&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quiz-1&quot;&gt;&lt;strong&gt;Quiz-1&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quiz-2&quot;&gt;&lt;strong&gt;Quiz-2&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#non-blocking-io--offloading&quot;&gt;&lt;strong&gt;non-blocking I/O &amp;amp; offloading&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;event-loop&quot;&gt;Event Loop&lt;/h2&gt;

&lt;p&gt;먼저 Event Loop부터 알아보도록 하겠습니다. &lt;strong&gt;Event Loop&lt;/strong&gt; 모델은 여러 스레드를 사용합니다. 그 중 우리가 작성한 JS 코드가 실행되는 스레드를 &lt;strong&gt;메인 스레드&lt;/strong&gt;라 부릅니다. &lt;br /&gt;
&lt;strong&gt;한 NodeJS 프로세스에서 메인 스레드는 하나이며, 한 순간에 한 줄씩만 실행됩니다.&lt;/strong&gt; 즉, 우리가 작성한 JS 코드가 동시에 여러줄 실행되는 경우는 적어도 한 프로세스 내에서는 없다고 볼 수 있습니다. &lt;br /&gt;
그러나, 그 외의 일(&lt;strong&gt;file I/O, network…&lt;/strong&gt;)을 하는 &lt;strong&gt;워커 스레드&lt;/strong&gt;는 여럿이 있을 수 있습니다.&lt;br /&gt; 이 NodeJS 프로세스 하나에서 메인 스레드가 하나이고, 한 순간에 한 줄씩만 실행된다는 제약은 굉장히 강력하고 효과적입니다. 이유는, 어떤 변수가 동시에 여러 실행 Context에 의해 뒤바뀔일이 없기 때문입니다. 따라서 &lt;strong&gt;프로그램의 상태를 예측하기가 훨씬 용이&lt;/strong&gt;하다는 뜻입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;call-stack&quot;&gt;Call Stack&lt;/h4&gt;

&lt;p&gt;그럼 &lt;strong&gt;Call Stack&lt;/strong&gt;은 무엇일까요? &lt;strong&gt;지금 시점까지 불린 함수들의 스택&lt;/strong&gt;이라고 할 수 있습니다. 스택 자료구조는 아래에서부터 쌓이는 &lt;strong&gt;FILO(First In Last Out)&lt;/strong&gt;형태의 자료구조이므로, &lt;strong&gt;Call Stack&lt;/strong&gt;은 함수가 호출될 때 생성되어 쌓이고 리턴할 때 제거됩니다. 다음과 같은 모습을 한다고 할 수 있죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/built/images/nodejs/callstack.png&quot; width=&quot;300&quot; height=&quot;450&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;그러면 Call Stack이 우리의 JavaScript 실행 모델과 어떤 연관이 있는지 살펴보자면, 다음 순서로 진행됩니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Call Stack은 빈 상태에서 시작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어떤 요인&lt;/strong&gt;에 의해 &lt;strong&gt;Callback&lt;/strong&gt;(함수)을 실행합니다.&lt;/li&gt;
  &lt;li&gt;Callback이 다른 함수를 부르고, 다른 함수가 또 다른 함수를 부르게 됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JavaScript는 위의 순서대로 작동되는데 중요한 것은, &lt;strong&gt;Event Loop가 다음 Callback을 처리하려면 지금 처리하고 있는 Callback의 실행이 완전히 끝나야 한다&lt;/strong&gt;는 것입니다.
Call Stack이 완전히 빌 때까지 처리한다는 것과 동일합니다. 이러한 JavaScript 실행 엔진의 특성을
&lt;strong&gt;Run-to-completion&lt;/strong&gt; 이라고 합니다.
&lt;br /&gt;다음 그림을 참고해주세요.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/built/images/nodejs/callback.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;callback-queue&quot;&gt;Callback Queue&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Callback Queue&lt;/strong&gt;는, Callback들이 쌓이는 Queue를 의미합니다. 설명이 너무 성의없었죠? 추가해서 말씀드리겠습니다. 일단 &lt;strong&gt;Queue&lt;/strong&gt; 자료구조는 맨 처음 들어온 자료가 제일 먼저 나가는 &lt;strong&gt;FIFO(First In First Out)&lt;/strong&gt;구조를 갖게 됩니다. 이런 Callback Queue는 &lt;strong&gt;Message Queue&lt;/strong&gt;라고도 부르는데, 앞으로 실행할 &lt;strong&gt;Callback(함수와 인자들)&lt;/strong&gt;들을 쌓아두는 Queue입니다. &lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;assets/built/images/nodejs/callback_queue.png&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Callback들은 브라우저나 Node가 &lt;strong&gt;어떤 일이 발생하면(Event)&lt;/strong&gt; 메인 스레드에 이를 알려주기 위해(&lt;strong&gt;Callback&lt;/strong&gt;) 사용됩니다. 이벤트의 종류로는 여러가지가 있는데 예로 &lt;strong&gt;파일 처리의 완료, 네트워크 작업의 완료, 타이머 호출&lt;/strong&gt; 등이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;quiz-1&quot;&gt;Quiz 1&lt;/h6&gt;

&lt;p&gt;이해를 점검하기 위해 문제를 한번 풀어보도록 합시다. 어떤 순서로 출력되어야 할까요??&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 함수들은 메인 함수로서 바로 &lt;strong&gt;Call Stack&lt;/strong&gt;에 들어가게 될 것입니다. 따라서 &lt;strong&gt;Call Stack&lt;/strong&gt;에서 한 줄씩 실행이 됩니다. &lt;strong&gt;setTimeout()의 0&lt;/strong&gt;값은, 0ms다음에 바로 Callback함수를 실행하라는 요청입니다. 다음과 같은 순서로 진행이 되겠죠?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log('1')&lt;/code&gt;이 실행됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout()&lt;/code&gt;이 실행됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log('3')&lt;/code&gt;이 실행됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 Callback은 실행되지 않습니다. 브라우저와 Node가 인식만 하고 있습니다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout()&lt;/code&gt;은 Node 혹은 브라우저에게 Callback을 실행해달라고 하고 다음순서로 넘어갔기 때문에 setTimeout()을 처리하고 일정시간이 지나고 나서야 setTimtout()안의 Callback을 Callback Queue에 입력하게 될 것입니다. &lt;br /&gt;
그러므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log('1')&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout()&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log('3')&lt;/code&gt;을 실행하고 난 뒤에야 Call Stack이 빈 상태가 되므로 그제서야 &lt;strong&gt;setTimeout()안의 Callback을 실행&lt;/strong&gt;할 것입니다. 그래서 정답은 &lt;strong&gt;1, 3, 2&lt;/strong&gt;가 됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;quiz-2&quot;&gt;Quiz 2&lt;/h6&gt;

&lt;p&gt;5초동안 메시지는 몇 번이나 출력되는 것이 맞을까요?&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Hey!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한번 생각해볼까요?
먼저 위의 코드가 실행되고 난 후에는 &lt;strong&gt;Call Stack&lt;/strong&gt;이 비어있을 것입니다. 그 후 Node나 브라우저는 내부적으로 동작하는 Timer로 1초 뒤에 &lt;strong&gt;Callback&lt;/strong&gt;을 &lt;strong&gt;Callback Queue&lt;/strong&gt;에 입력하게 됩니다. &lt;br /&gt;
Call Stack이 비어있는 상태이기 때문에 Callback Queue에서 하나의 Callback을 꺼내서 실행을 하게 됩니다(위의 코드). 또 매초 후에 Callback을 다시 Callback Queue에 입력하게 됩니다. 그럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log()&lt;/code&gt;가 4번이 출력되는게 맞을까요? &lt;br /&gt;
아닙니다. 정답은 &lt;strong&gt;1번&lt;/strong&gt;입니다. 이유는, &lt;strong&gt;while loop이 도는 동안 Call Stack이 절대 비지 않기 때문&lt;/strong&gt;입니다. &lt;strong&gt;Call Stack이 비어있으려면, Callback이 어떻게든 return을 해야합니다.&lt;/strong&gt; 그러나 위의 코드에서는 return이 절대로 일어날 수 없는 상황이었죠.&lt;br /&gt;
이 동안은 &lt;strong&gt;Callback Queue에서 Callback을 꺼낼 수가 없기 때문에&lt;/strong&gt;, &lt;strong&gt;setInterval이 아무리 Callback을 쌓아도 메인 스레드에서 실행될 수가 없습니다.&lt;/strong&gt; 이러한 경우를 &lt;strong&gt;Event Loop&lt;/strong&gt;을 &lt;strong&gt;block&lt;/strong&gt;한다고 합니다. &lt;br /&gt;
따라서 n&lt;strong&gt;on-blocking I/O를 Node에서 가장 기본적인 형태로서 사용&lt;/strong&gt;하게 됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;non-blocking-io--offloading&quot;&gt;non-blocking I/O &amp;amp; offloading&lt;/h4&gt;

&lt;p&gt;앞으로 자주 보게 될 다음 코드를 분석하면서 시작해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;someTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드는 Call Stack에 입력됩니다.
첫 줄에서는 Node에게 파일을 읽어달라고 요청하고, (메인 스레드에서 파일을 읽는 것이 아닌) 워커 스레드에서 파일을 읽기 시작합니다. &lt;br /&gt;
메인 스레드는 첫 줄을 실행했으니, 다음 줄을 실행하게 되겠죠. &lt;strong&gt;readFile()&lt;/strong&gt;의 호출이 끝난 직후 &lt;strong&gt;someTask()&lt;/strong&gt;를 실행하게 됩니다. Call Stack이 빌 때 까지 계속 처리를 수행해 주어야 하기 때문이지요. &lt;br /&gt;
그럼 어느 순간에 Node의 워커 스레드가 파일을 다 읽거나 에러를 출력하게 될 텐데,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Callback Queue에 Callback 함수와, 함수의 err, data인자를 채워서 넣고&lt;/li&gt;
  &lt;li&gt;Callback Queue에서 꺼내진 후 Call Stack에 입력될 때, 이 부분이 실행됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;요약하자면 다음과 같습니다. 브라우저나 NodeJS에서나, Callback은 &lt;strong&gt;Web API 또는 Node API의 동작이 끝나면&lt;/strong&gt; &lt;strong&gt;Callback Queue에 등록&lt;/strong&gt;합니다. 그 후 브라우저나 Node가 요청받은 일을 하고 있는 동안은, &lt;strong&gt;메인 스레드&lt;/strong&gt;와 &lt;strong&gt;Event Loop&lt;/strong&gt;는 영향을 받지 않고 계속 실행됩니다. &lt;br /&gt;
이런 현상을 &lt;strong&gt;offloading&lt;/strong&gt;이라고 하며, &lt;strong&gt;Node 서버의 메인 스레드가 하나임에도 불구하고 빠르게 동작할 수 있는 이유&lt;/strong&gt;입니다. &lt;strong&gt;메인 스레드가 오래 걸릴 일을 기다리지 않기 때문&lt;/strong&gt;이죠.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;지금까지의 내용을 바탕으로 Event Loop에 대한 내용을 정리해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/built/images/nodejs/eventloop.png&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Callback Queue에서 Callback을 꺼내고 (없다면 생길 때까지 기다리고)&lt;/li&gt;
  &lt;li&gt;Callback의 처리가 끝날 때까지 Call Stack안의 내부 함수들을 실행하고&lt;/li&gt;
  &lt;li&gt;이를 반복합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;하나의 Callback을 처리하는 동안에 여러가지 호출이 있을 수 있습니다. NodeJS API/ Web API를 호출하게 될텐데, 브라우저와 Node는 그것들을 받아서 워커 스레드에게 일을 시킬 것입니다. &lt;br /&gt;
워커 스레드가 일을 다 하고 나서 &lt;strong&gt;JavaScript에게 알려줘야 할 것이 있다면 Callback Queue에 알려줄 것을 등록&lt;/strong&gt;하게 되는 것이지요.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Woo Chang Uk</name>
        
        
      </author>

      

      
        <category term="backend" />
      

      
        <summary type="html">안녕하세요. 성장하는 것을 즐기는 changuk이라고 합니다. 현재 fastcampus에서 backend 개발을 공부하고 있습니다. 강의를 들으면서 해온 것들을 작성하여 지식을 공유하고 또 제가 잊었을 때 다시 와서 볼 수 있도록 내용들을 정리하려고 합니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Backend - NodeJS SETUP</title>
      <link href="http://localhost:4000/backend-setup" rel="alternate" type="text/html" title="Backend - NodeJS SETUP" />
      <published>2022-02-04T09:00:00+09:00</published>
      <updated>2022-02-04T09:00:00+09:00</updated>
      <id>http://localhost:4000/backend-setup</id>
      <content type="html" xml:base="http://localhost:4000/backend-setup">&lt;p&gt;안녕하세요. 성장하는 것을 즐기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;changuk&lt;/code&gt;이라고 합니다. 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastcampus&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend&lt;/code&gt; 개발을 공부하고 있습니다. 강의를 들으면서 해온 것들을 작성하여 지식을 공유하고 또 제가 잊었을 때 다시 와서 볼 수 있도록 내용들을 정리하려고 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이번시간은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeJS SETUP&lt;/code&gt;을 진행하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;contents&quot;&gt;Contents&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#setup&quot;&gt;&lt;strong&gt;Setup&lt;/strong&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vscode-javascript-development-setup&quot;&gt;&lt;strong&gt;VSCode JS Dev Setup&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;

&lt;p&gt;높은 생산성을 위해서는 개발환경을 잘 세팅해두는 것이 필수적이라고 할 수 있습니다. 개발을 편하게 하는 패키지들 중 하나인 &lt;strong&gt;Formatter&lt;/strong&gt;와 &lt;strong&gt;Linter&lt;/strong&gt;를 먼저 설치해주도록 하겠습니다. &lt;br /&gt;
Formatter는 띄어쓰기나 들여쓰기가 잘 되어 있는지, 비주얼적인 요소를 바로바로 맞춰주는 패키지라고 할 수 있고, Linter는 자체적으로 권장하는 문법에 맞지 않으면 에러를 발생시켜서 수정하도록 하는 패키지라고 할 수 있습니다.npm으로 개발 의존성 패키지가 되도록 설치하도록 하겠습니다.
이 두 패키지는 설치해주고 VSCode Extensions를 따로 설치해 주셔야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;npm i -D prettier eslint&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;그리고 Airbnb에서 제공하는 &lt;a href=&quot;https://github.com/airbnb/javascript&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;JavaScript Style Guide&lt;/strong&gt;&lt;/a&gt;를 설치하도록 하겠습니다. JavaScript 개발에 가장 합리적인 접근이라고 하네요. 또 이 플러그인을 연결해줄 수 있도록 새로운 패키지도 설치하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;npm i -D eslint-airbnb-base eslint-plugin-import&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;prettier와 eslint가 서로 충돌할 수 있기 때문에, 다음 플러그인도 설치해 주어야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;npm i -D eslint-config-prettier&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;eslint가 NodeJS환경에서도 잘 동작할 수 있는 플러그인도 설치하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;npm i -D eslint-plugin-node&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;당장 TypeScript를 사용하는 것은 아니지만, TypeScript의 Type Checking을 이용하기 위해, 이 패키지도 설치하도록 하죠.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;npm i -D typescript&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;그리고 Type Checking을 할 수 있도록 다음 라인을 js파일의 처음에 입력해주면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//@ts-check&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또, node환경에서의 주로 사용하는 객체들에 대한 Type 정보들에 Type Checking을 수행해주기 위해서 아래 패키지도 또 설치하도록 하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;npm i -D @types/node&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;prettier, eslint 각각의 설정 파일을 다음과 같이 만들도록 하겠습니다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.prettierrc&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;.eslintrc.js&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;prettier의 설정은, 본인의 기호에 맞게 세팅해주면 됩니다. 기본적인 설정만 이용해도 만족감은 상당하죠. &lt;br /&gt;
&lt;strong&gt;.eslintrc.js&lt;/strong&gt;파일에는 설정을 좀 추가하도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 이 순서대로 작성해 주어야 한다.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;extends&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;airbnb-base&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;plugin:node/recommended&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;prettier&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;jsconfig.json&lt;/strong&gt;파일을 생성하고 다음 내용을 기입하여 설정을 마무리 해주도록 하겠습니다. 엄격한 컴파일 옵션을 설정해주고, src 밑의 모든 파일들을 확인해주겠다는 의미로 이해하시면 될 것 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;compilerOptions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;strict&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;include&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src밑의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;모든&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;파일들&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/**/*&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Setup내용을 간략하게 표로 정리했습니다.&lt;/p&gt;

&lt;h4 id=&quot;vscode-javascript-development-setup&quot;&gt;VSCode JavaScript Development Setup&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Formatting&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Linting&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Type Checking&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;Package&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;prettier&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;eslint&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;typescript&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;br /&gt;Additional &lt;br /&gt;dependencies&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;eslint-config-airbnb-base&lt;br /&gt; eslint-config-prettier&lt;br /&gt; eslint-plugin-import&lt;br /&gt;eslint-plugin-node&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;@types/node&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;Config file&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;.prettierrc&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;.eslintrc.js&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jsconfig.json&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;VSCode&lt;br /&gt;extensions&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content>

      
      
      
      
      

      <author>
          <name>Woo Chang Uk</name>
        
        
      </author>

      

      
        <category term="backend" />
      

      
        <summary type="html">안녕하세요. 성장하는 것을 즐기는 changuk이라고 합니다. 현재 fastcampus에서 backend 개발을 공부하고 있습니다. 강의를 들으면서 해온 것들을 작성하여 지식을 공유하고 또 제가 잊었을 때 다시 와서 볼 수 있도록 내용들을 정리하려고 합니다.</summary>
      

      
      
    </entry>
  
</feed>
